<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPC: Pasaje de Mensajes y Barreras</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        
        .presentation {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .slide {
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 60px;
            display: none;
            flex-direction: column;
            position: relative;
            animation: slideIn 0.5s ease-out;
        }
        
        .slide.active {
            display: flex;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(100px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .slide-header {
            border-bottom: 4px solid #667eea;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        
        .slide-title {
            font-size: 48px;
            color: #2d3748;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .slide-subtitle {
            font-size: 24px;
            color: #667eea;
            font-weight: 500;
        }
        
        .slide-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 20px;
        }
        
        .slide-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .slide-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        .slide-content::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }
        
        h2 {
            color: #667eea;
            font-size: 32px;
            margin: 25px 0 15px 0;
        }
        
        h3 {
            color: #764ba2;
            font-size: 24px;
            margin: 20px 0 10px 0;
        }
        
        p, li {
            font-size: 20px;
            line-height: 1.6;
            color: #4a5568;
            margin: 10px 0;
        }
        
        ul {
            margin-left: 30px;
        }
        
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            margin: 20px 0;
            overflow-x: auto;
            line-height: 1.5;
        }
        
        .highlight {
            background: #fef3c7;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .box {
            background: #f7fafc;
            border-left: 5px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            background: #f7fafc;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
        }
        
        .comparison-item h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        .navigation {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 15px;
        }
        
        .nav-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .nav-btn:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .nav-btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }
        
        .slide-number {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: #a0aec0;
            font-size: 18px;
            font-weight: 600;
        }
        
        .presenter-tag {
            position: absolute;
            top: 20px;
            right: 30px;
            background: #667eea;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .diagram {
            background: white;
            border: 3px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-family: monospace;
            font-size: 16px;
            line-height: 2;
        }
        
        .arrow {
            color: #667eea;
            font-size: 24px;
            font-weight: bold;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 2px solid #e2e8f0;
            padding: 15px;
            text-align: left;
        }
        
        th {
            background: #667eea;
            color: white;
            font-size: 18px;
        }
        
        .intro-content {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            height: 100%;
        }
        
        .intro-content .slide-title {
            font-size: 64px;
            margin-bottom: 20px;
        }
        
        .intro-content .slide-subtitle {
            font-size: 32px;
        }
        
        .team-list {
            margin-top: 40px;
            font-size: 24px;
            color: #4a5568;
        }
    </style>
</head>
<body>
    <div class="presentation">
        <!-- Slide 1: Portada -->
        <div class="slide active">
            <div class="intro-content">
                <div class="slide-title">ComunicaciÃ³n Entre Procesos</div>
                <div class="slide-subtitle">Pasaje de Mensajes y Barreras</div>
                <div class="team-list">
                    <p><strong>Expositores:</strong></p>
                    <p>Derek Marmol | Daniel Ortiz</p>
                    <p>Ergil Cardenas | Diego Contreras</p>
                </div>
            </div>
            <div class="slide-number">1 / 19</div>
        </div>

        <!-- Slide 2: Ãndice -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-title">Ãndice</div>
            </div>
            <div class="slide-content">
                <h2>Contenido de la PresentaciÃ³n</h2>
                <div style="font-size: 24px; line-height: 2.5;">
                    <p><strong>Parte 1: Pasaje de Mensajes (Derek y Daniel)</strong></p>
                    <ul>
                        <li>IntroducciÃ³n y conceptos fundamentales</li>
                        <li>Tipos de comunicaciÃ³n (directa/indirecta)</li>
                        <li>SincronizaciÃ³n: Bloqueante vs No bloqueante</li>
                        <li>Buffering y ejemplos prÃ¡cticos</li>
                    </ul>
                    <br>
                    <p><strong>Parte 2: Barreras (Ergil y Diego)</strong></p>
                    <ul>
                        <li>Concepto y propÃ³sito de las barreras</li>
                        <li>Funcionamiento y tipos</li>
                        <li>ImplementaciÃ³n y ejemplos</li>
                        <li>ComparaciÃ³n con otros mecanismos</li>
                    </ul>
                </div>
            </div>
            <div class="slide-number">2 / 19</div>
        </div>

        <!-- PARTE 1: PASAJE DE MENSAJES (DEREK - 4 SLIDES) -->
        
        <!-- Slide 3 - Derek -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Derek Marmol</div>
            <div class="slide-header">
                <div class="slide-title">Pasaje de Mensajes</div>
                <div class="slide-subtitle">IntroducciÃ³n y Primitivas BÃ¡sicas</div>
            </div>
            <div class="slide-content">
                <h2>Â¿QuÃ© es el Pasaje de Mensajes?</h2>
                <p>El <span class="highlight">pasaje de mensajes</span> es un mÃ©todo de comunicaciÃ³n entre procesos que utiliza dos primitivas que son <strong>llamadas al sistema</strong> (no construcciones del lenguaje como los monitores).</p>
                
                <div class="box">
                    <h3>CaracterÃ­sticas Principales:</h3>
                    <ul>
                        <li><strong>No requiere memoria compartida:</strong> Ideal para procesos en distintas mÃ¡quinas conectadas por red</li>
                        <li><strong>Llamadas al sistema:</strong> send y receive son primitivas del SO</li>
                        <li><strong>Pueden colocarse en procedimientos de biblioteca</strong> para facilitar su uso</li>
                        <li><strong>Comportamiento del receive:</strong> Si no hay mensaje disponible, el receptor puede bloquearse o regresar con cÃ³digo de error</li>
                    </ul>
                </div>

                <h2>Primitivas BÃ¡sicas</h2>
                <div class="code-block">send(destino, &mensaje);    // Enviar mensaje a destino
receive(origen, &mensaje);   // Recibir mensaje de origen o CUALQUIERA</div>

                <p><strong>Nota importante:</strong> El parÃ¡metro "origen" en receive puede ser un proceso especÃ­fico o la constante CUALQUIERA si al receptor no le importa de quiÃ©n viene el mensaje.</p>
            </div>
            <div class="slide-number">3 / 19</div>
        </div>

        <!-- Slide 4 - Derek -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Derek Marmol</div>
            <div class="slide-header">
                <div class="slide-title">Tipos de ComunicaciÃ³n</div>
                <div class="slide-subtitle">Direccionamiento Directo e Indirecto</div>
            </div>
            <div class="slide-content">
                <h2>1. ComunicaciÃ³n Directa</h2>
                <p>Los procesos se nombran explÃ­citamente entre sÃ­.</p>
                <div class="code-block">// Proceso P1
send(P2, mensaje);           // Enviar a P2 directamente

// Proceso P2
receive(P1, &mensaje);       // Recibir de P1 directamente</div>
                
                <div class="box">
                    <p><strong>CaracterÃ­sticas:</strong></p>
                    <ul>
                        <li>VÃ­nculo automÃ¡tico entre procesos</li>
                        <li>ComunicaciÃ³n uno a uno</li>
                        <li>Ambos procesos deben conocerse</li>
                    </ul>
                </div>

                <h2>2. ComunicaciÃ³n Indirecta (Buzones/Puertos)</h2>
                <p>Los mensajes se envÃ­an y reciben a travÃ©s de <span class="highlight">buzones</span> o <span class="highlight">puertos</span>.</p>
                <div class="code-block">// Proceso P1
send(MailboxA, mensaje);     // Enviar al buzÃ³n A

// Proceso P2 o P3 pueden recibir
receive(MailboxA, &mensaje); // Recibir del buzÃ³n A</div>

                <div class="box">
                    <p><strong>Ventajas:</strong></p>
                    <ul>
                        <li>Flexibilidad: mÃºltiples procesos pueden usar el mismo buzÃ³n</li>
                        <li>Desacoplamiento: los procesos no necesitan conocerse</li>
                        <li>ComunicaciÃ³n uno a muchos o muchos a uno</li>
                    </ul>
                </div>
            </div>
            <div class="slide-number">4 / 19</div>
        </div>

        <!-- Slide 5 - Derek -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Derek Marmol</div>
            <div class="slide-header">
                <div class="slide-title">Diagrama de ComunicaciÃ³n</div>
                <div class="slide-subtitle">Visual de Directa vs Indirecta</div>
            </div>
            <div class="slide-content">
                <h2>ComunicaciÃ³n Directa</h2>
                <div class="diagram">
                    Proceso P1  <span class="arrow">â†’</span>  [mensaje]  <span class="arrow">â†’</span>  Proceso P2
                    <br>
                    (ConexiÃ³n punto a punto)
                </div>

                <h2>ComunicaciÃ³n Indirecta</h2>
                <div class="diagram">
                    Proceso P1  <span class="arrow">â†’</span>  [BuzÃ³n A]  <span class="arrow">â†</span>  Proceso P2
                    <br>
                    Proceso P3  <span class="arrow">â†’</span>  [BuzÃ³n A]  <span class="arrow">â†</span>  Proceso P4
                    <br>
                    (MÃºltiples procesos pueden acceder al buzÃ³n)
                </div>

                <div class="box">
                    <h3>AnalogÃ­a del mundo real:</h3>
                    <p><strong>Directa:</strong> Es como hacer una llamada telefÃ³nica directa a una persona especÃ­fica.</p>
                    <p><strong>Indirecta:</strong> Es como enviar un correo a una casilla postal que varias personas pueden revisar.</p>
                </div>
            </div>
            <div class="slide-number">5 / 19</div>
        </div>

        <!-- Slide 6 - Derek NUEVA -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Derek Marmol</div>
            <div class="slide-header">
                <div class="slide-title">Ventajas y Desventajas del Pasaje de Mensajes</div>
                <div class="slide-subtitle">AnÃ¡lisis Comparativo</div>
            </div>
            <div class="slide-content">
                <h2>Ventajas del Pasaje de Mensajes</h2>
                <div class="comparison">
                    <div class="comparison-item">
                        <h4>âœ… Portabilidad</h4>
                        <p>Funciona en sistemas distribuidos sin memoria compartida. Ideal para comunicaciÃ³n en red entre diferentes mÃ¡quinas.</p>
                    </div>
                    
                    <div class="comparison-item">
                        <h4>âœ… Simplicidad Conceptual</h4>
                        <p>MÃ¡s fÃ¡cil de razonar que memoria compartida. No hay condiciones de carrera directas sobre datos compartidos.</p>
                    </div>
                </div>

                <div class="comparison">
                    <div class="comparison-item">
                        <h4>âœ… Modularidad</h4>
                        <p>Los procesos estÃ¡n naturalmente desacoplados. Cambiar un proceso no afecta directamente a otros.</p>
                    </div>
                    
                    <div class="comparison-item">
                        <h4>âœ… Seguridad</h4>
                        <p>Cada proceso tiene su propio espacio de direcciones protegido. Menor riesgo de corrupciÃ³n de memoria.</p>
                    </div>
                </div>

                <h2>Desventajas del Pasaje de Mensajes</h2>
                <div class="box" style="background: #fee;">
                    <ul>
                        <li><strong>Overhead de comunicaciÃ³n:</strong> Copiar mensajes entre espacios de direcciones tiene costo en tiempo y memoria</li>
                        <li><strong>Complejidad de sincronizaciÃ³n:</strong> Gestionar el orden y timing de mensajes puede ser complicado</li>
                        <li><strong>Latencia:</strong> Especialmente en sistemas distribuidos, el envÃ­o de mensajes puede ser lento</li>
                        <li><strong>GestiÃ³n de buzones:</strong> Requiere administrar colas, manejar buzones llenos, y prevenir deadlocks</li>
                    </ul>
                </div>

                <div class="box">
                    <h3>Â¿CuÃ¡ndo usar Pasaje de Mensajes?</h3>
                    <p><strong>Ideal para:</strong> Sistemas distribuidos, arquitecturas de microservicios, cuando los procesos estÃ¡n en diferentes mÃ¡quinas, o cuando se necesita alta modularidad y desacoplamiento.</p>
                </div>
            </div>
            <div class="slide-number">6 / 19</div>
        </div>

        <!-- PARTE 1: PASAJE DE MENSAJES (DANIEL - 4 SLIDES) -->
        
        <!-- Slide 7 - Daniel -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Daniel Ortiz</div>
            <div class="slide-header">
                <div class="slide-title">SincronizaciÃ³n en Pasaje de Mensajes</div>
                <div class="slide-subtitle">Bloqueante vs No Bloqueante</div>
            </div>
            <div class="slide-content">
                <h2>Tipos de SincronizaciÃ³n</h2>
                
                <div class="comparison">
                    <div class="comparison-item">
                        <h4>ğŸ”’ Bloqueante (SincrÃ³nico)</h4>
                        <p><strong>Send bloqueante:</strong> El emisor se bloquea hasta que el receptor reciba el mensaje.</p>
                        <p><strong>Receive bloqueante:</strong> El receptor se bloquea hasta que llegue un mensaje.</p>
                        <div class="code-block" style="font-size: 14px;">send(destino, msg);
// Se bloquea aquÃ­
// hasta que se reciba</div>
                    </div>
                    
                    <div class="comparison-item">
                        <h4>ğŸ”“ No Bloqueante (AsincrÃ³nico)</h4>
                        <p><strong>Send no bloqueante:</strong> El emisor continÃºa inmediatamente despuÃ©s de enviar.</p>
                        <p><strong>Receive no bloqueante:</strong> Retorna inmediatamente con mensaje o NULL.</p>
                        <div class="code-block" style="font-size: 14px;">send(destino, msg);
// ContinÃºa aquÃ­
// inmediatamente</div>
                    </div>
                </div>

                <h2>Combinaciones Posibles</h2>
                <table>
                    <tr>
                        <th>Send</th>
                        <th>Receive</th>
                        <th>Resultado</th>
                    </tr>
                    <tr>
                        <td>Bloqueante</td>
                        <td>Bloqueante</td>
                        <td>Rendez-vous (encuentro sincronizado)</td>
                    </tr>
                    <tr>
                        <td>No Bloqueante</td>
                        <td>Bloqueante</td>
                        <td>MÃ¡s comÃºn en la prÃ¡ctica</td>
                    </tr>
                    <tr>
                        <td>No Bloqueante</td>
                        <td>No Bloqueante</td>
                        <td>Totalmente asincrÃ³nico</td>
                    </tr>
                </table>
            </div>
            <div class="slide-number">7 / 19</div>
        </div>

        <!-- Slide 8 - Daniel -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Daniel Ortiz</div>
            <div class="slide-header">
                <div class="slide-title">Buffering de Mensajes</div>
                <div class="slide-subtitle">Â¿DÃ³nde se almacenan los mensajes?</div>
            </div>
            <div class="slide-content">
                <h2>Estrategias de Almacenamiento</h2>
                
                <h3>1. Capacidad Cero (Sin Buffer)</h3>
                <div class="box">
                    <p>No hay cola de espera. El emisor <strong>debe esperar</strong> al receptor.</p>
                    <p><strong>Uso:</strong> SincronizaciÃ³n estricta (rendez-vous)</p>
                </div>

                <h3>2. Capacidad Limitada</h3>
                <div class="box">
                    <p>Cola de tamaÃ±o finito (n mensajes). Si la cola estÃ¡ llena, el emisor se bloquea.</p>
                    <div class="code-block">// Buffer de 10 mensajes
Mailbox buffer[10];
if (buffer_full()) {
    wait(); // Emisor espera
}</div>
                </div>

                <h3>3. Capacidad Ilimitada</h3>
                <div class="box">
                    <p>Cola de tamaÃ±o infinito (teÃ³rico). El emisor <strong>nunca espera</strong>.</p>
                    <p><strong>LimitaciÃ³n:</strong> Recursos finitos en sistemas reales</p>
                </div>

                <div class="diagram">
                    Emisor â†’ [Buffer: â–¢ â–¢ â–¢] â†’ Receptor
                    <br>
                    (Los mensajes esperan si el receptor estÃ¡ ocupado)
                </div>
            </div>
            <div class="slide-number">8 / 19</div>
        </div>

        <!-- Slide 9 - Daniel -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Daniel Ortiz</div>
            <div class="slide-header">
                <div class="slide-title">Ejemplo PrÃ¡ctico: Productor-Consumidor</div>
                <div class="slide-subtitle">ImplementaciÃ³n con Pasaje de Mensajes</div>
            </div>
            <div class="slide-content">
                <h2>Problema ClÃ¡sico Resuelto con Mensajes</h2>
                
                <div class="code-block">#define N 100  // TamaÃ±o del buffer

void producer(void) {
    int item;
    message m;
    
    while (TRUE) {
        item = produce_item();
        receive(consumer, &m);      // Esperar mensaje vacÃ­o
        build_message(&m, item);
        send(consumer, &m);         // Enviar mensaje lleno
    }
}

void consumer(void) {
    int item;
    message m;
    
    for (int i = 0; i < N; i++) {
        send(producer, &m);         // Enviar N mensajes vacÃ­os
    }
    
    while (TRUE) {
        receive(producer, &m);      // Recibir mensaje lleno
        item = extract_item(&m);
        send(producer, &m);         // Devolver mensaje vacÃ­o
        consume_item(item);
    }
}</div>

                <div class="box">
                    <h3>Ventajas de esta soluciÃ³n:</h3>
                    <ul>
                        <li>No requiere memoria compartida</li>
                        <li>SincronizaciÃ³n automÃ¡tica</li>
                        <li>Sin condiciones de carrera</li>
                        <li>CÃ³digo mÃ¡s simple y claro</li>
                    </ul>
                </div>
            </div>
            <div class="slide-number">9 / 19</div>
        </div>

        <!-- Slide 10 - Daniel NUEVA -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Daniel Ortiz</div>
            <div class="slide-header">
                <div class="slide-title">Problemas Comunes y Soluciones</div>
                <div class="slide-subtitle">Deadlocks y GestiÃ³n de Errores</div>
            </div>
            <div class="slide-content">
                <h2>Problema 1: Deadlock en Pasaje de Mensajes</h2>
                <div class="box" style="background: #fee;">
                    <h3>Escenario de Deadlock:</h3>
                    <div class="code-block">// Proceso A
send(B, msg1);
receive(B, &msg2);

// Proceso B
send(A, msg1);
receive(A, &msg2);</div>
                    <p><strong>Problema:</strong> Ambos intentan enviar primero con send bloqueante. Ambos se bloquean esperando que el otro reciba.</p>
                </div>

                <div class="box" style="background: #d1fae5;">
                    <h3>SoluciÃ³n: Ordenamiento o AsincronÃ­a</h3>
                    <div class="code-block">// SoluciÃ³n 1: Orden establecido
// Proceso A (siempre envÃ­a primero)
send(B, msg1);
receive(B, &msg2);

// Proceso B (siempre recibe primero)
receive(A, &msg2);
send(A, msg1);

// SoluciÃ³n 2: Send no bloqueante
send_nonblock(B, msg1);
receive(B, &msg2);</div>
                </div>

                <h2>Problema 2: Mensajes Perdidos</h2>
                <div class="comparison">
                    <div class="comparison-item">
                        <h4>âš ï¸ Causas</h4>
                        <ul>
                            <li>Buffer lleno y sin manejo</li>
                            <li>Proceso receptor termina antes de recibir</li>
                            <li>Errores de red en sistemas distribuidos</li>
                        </ul>
                    </div>
                    
                    <div class="comparison-item">
                        <h4>âœ… Soluciones</h4>
                        <ul>
                            <li>Implementar ACKs (acknowledgments)</li>
                            <li>Timeout y reenvÃ­o</li>
                            <li>NÃºmeros de secuencia</li>
                            <li>Manejo explÃ­cito de errores</li>
                        </ul>
                    </div>
                </div>

                <h2>Buenas PrÃ¡cticas</h2>
                <div class="box">
                    <ul>
                        <li>Siempre verificar el retorno de receive() para detectar errores</li>
                        <li>Usar timeouts para evitar bloqueos indefinidos</li>
                        <li>Documentar el protocolo de comunicaciÃ³n claramente</li>
                        <li>Considerar el orden de operaciones send/receive cuidadosamente</li>
                    </ul>
                </div>
            </div>
            <div class="slide-number">10 / 19</div>
        </div>

        <!-- Slide 11: TransiciÃ³n -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-title">TransiciÃ³n</div>
                <div class="slide-subtitle">De Pasaje de Mensajes a Barreras</div>
            </div>
            <div class="slide-content">
                <div style="display: flex; flex-direction: column; justify-content: center; height: 100%; text-align: center;">
                    <h2 style="font-size: 48px; color: #667eea; margin-bottom: 40px;">Hemos visto: Pasaje de Mensajes</h2>
                    <p style="font-size: 28px; margin: 20px 0;">âœ“ ComunicaciÃ³n entre procesos sin memoria compartida</p>
                    <p style="font-size: 28px; margin: 20px 0;">âœ“ Tipos de comunicaciÃ³n y sincronizaciÃ³n</p>
                    <p style="font-size: 28px; margin: 20px 0;">âœ“ Buffering y ejemplos prÃ¡cticos</p>
                    <p style="font-size: 28px; margin: 20px 0;">âœ“ Problemas comunes y soluciones</p>
                    
                    <div style="margin: 60px 0; font-size: 48px; color: #764ba2;">â¬‡ï¸</div>
                    
                    <h2 style="font-size: 48px; color: #764ba2;">Ahora veremos: Barreras</h2>
                    <p style="font-size: 24px; margin-top: 20px; color: #4a5568;">Un mecanismo de sincronizaciÃ³n para mÃºltiples procesos</p>
                </div>
            </div>
            <div class="slide-number">11 / 19</div>
        </div>

        <!-- PARTE 2: BARRERAS (ERGIL - 4 SLIDES) -->
        
        <!-- Slide 12 - Ergil -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Ergil Cardenas</div>
            <div class="slide-header">
                <div class="slide-title">Barreras</div>
                <div class="slide-subtitle">Concepto y PropÃ³sito</div>
            </div>
            <div class="slide-content">
                <h2>Â¿QuÃ© es una Barrera?</h2>
                <p>Una <span class="highlight">barrera</span> es un mecanismo de sincronizaciÃ³n que fuerza a un grupo de procesos (o hilos) a esperar hasta que <strong>todos</strong> hayan alcanzado un punto especÃ­fico antes de continuar.</p>

                <div class="box">
                    <h3>CaracterÃ­sticas Principales:</h3>
                    <ul>
                        <li><strong>SincronizaciÃ³n de grupo:</strong> Todos los procesos deben llegar</li>
                        <li><strong>Punto de encuentro:</strong> Define una fase en la ejecuciÃ³n</li>
                        <li><strong>LiberaciÃ³n simultÃ¡nea:</strong> Todos continÃºan juntos</li>
                        <li><strong>Uso comÃºn:</strong> ComputaciÃ³n paralela y aplicaciones cientÃ­ficas</li>
                    </ul>
                </div>

                <h2>AnalogÃ­a del Mundo Real</h2>
                <div class="diagram">
                    ğŸš¶ ğŸš¶ ğŸš¶ ğŸš¶  â†’  [ğŸš§ BARRERA ğŸš§]  â†’  ğŸƒ ğŸƒ ğŸƒ ğŸƒ
                    <br>
                    Todos esperan      Barrera         Todos continÃºan
                    <br><br>
                    "Como un grupo de turistas que espera a que<br>
                    todos lleguen al bus antes de partir"
                </div>

                <div class="box" style="background: #fef3c7;">
                    <p><strong>âš ï¸ Importante:</strong> Si un proceso no llega a la barrera, TODOS los demÃ¡s quedan bloqueados indefinidamente.</p>
                </div>
            </div>
            <div class="slide-number">12 / 19</div>
        </div>

        <!-- Slide 13 - Ergil -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Ergil Cardenas</div>
            <div class="slide-header">
                <div class="slide-title">Funcionamiento de las Barreras</div>
                <div class="slide-subtitle">Paso a Paso</div>
            </div>
            <div class="slide-content">
                <h2>Proceso de SincronizaciÃ³n</h2>
                
                <div class="diagram" style="text-align: left; line-height: 2.5;">
                    <strong>Fase 1: Llegada</strong><br>
                    Proceso 1: â•â•â•â•â•â•â•â•â•â•â•â•â•—<br>
                    Proceso 2: â•â•â•â•â•â•â•—     â•‘<br>
                    Proceso 3: â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â–º [BARRERA]<br>
                    Proceso 4: â•â•â•â•â•â•â•â•â•â•  â•‘<br>
                    <br>
                    <strong>Fase 2: Espera</strong><br>
                    Todos esperan en la barrera: â¸ï¸ â¸ï¸ â¸ï¸ â¸ï¸<br>
                    Contador: 1... 2... 3... 4 âœ“<br>
                    <br>
                    <strong>Fase 3: LiberaciÃ³n</strong><br>
                    â•â•â•â–º Proceso 1 continÃºa<br>
                    â•â•â•â–º Proceso 2 continÃºa<br>
                    â•â•â•â–º Proceso 3 continÃºa<br>
                    â•â•â•â–º Proceso 4 continÃºa<br>
                </div>

                <h2>Primitiva BÃ¡sica</h2>
                <div class="code-block">barrier_wait(barrier_t *barrier);

// Cuando un proceso llama a barrier_wait():
// 1. Incrementa contador de llegadas
// 2. Si no son todos: se bloquea
// 3. Si son todos: despierta a todos</div>

                <div class="box">
                    <p><strong>Estado interno de la barrera:</strong></p>
                    <ul>
                        <li>Contador de procesos llegados</li>
                        <li>NÃºmero total de procesos esperados</li>
                        <li>Mecanismo de bloqueo/liberaciÃ³n</li>
                    </ul>
                </div>
            </div>
            <div class="slide-number">13 / 19</div>
        </div>

        <!-- Slide 14 - Ergil -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Ergil Cardenas</div>
            <div class="slide-header">
                <div class="slide-title">Tipos de Barreras</div>
                <div class="slide-subtitle">Diferentes Implementaciones</div>
            </div>
            <div class="slide-content">
                <h2>1. Barrera Simple (One-time)</h2>
                <div class="box">
                    <p>Se usa una sola vez. DespuÃ©s de liberarse, no puede reutilizarse.</p>
                    <p><strong>Uso:</strong> SincronizaciÃ³n Ãºnica al inicio o fin de programa</p>
                </div>

                <h2>2. Barrera Reutilizable (Reusable)</h2>
                <div class="box">
                    <p>Puede usarse mÃºltiples veces en ciclos. Se resetea automÃ¡ticamente despuÃ©s de cada liberaciÃ³n.</p>
                    <div class="code-block">for (int fase = 0; fase < N; fase++) {
    // Trabajo de la fase
    realizar_computo();
    
    // SincronizaciÃ³n al final de cada fase
    barrier_wait(&barrera);
    
    // Todos continÃºan a la siguiente fase
}</div>
                    <p><strong>Uso:</strong> Algoritmos iterativos, simulaciones paralelas</p>
                </div>

                <h2>3. Barrera con Sentido (Sense-reversing)</h2>
                <div class="box">
                    <p>Usa una variable "sentido" que alterna para detectar nuevas rondas.</p>
                    <p><strong>Ventaja:</strong> Evita condiciones de carrera en reutilizaciones</p>
                </div>
            </div>
            <div class="slide-number">14 / 19</div>
        </div>

        <!-- Slide 15 - Ergil NUEVA -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Ergil Cardenas</div>
            <div class="slide-header">
                <div class="slide-title">Aplicaciones Reales de Barreras</div>
                <div class="slide-subtitle">Casos de Uso en la Industria</div>
            </div>
            <div class="slide-content">
                <h2>1. Simulaciones CientÃ­ficas</h2>
                <div class="box">
                    <h3>DinÃ¡mica de Fluidos Computacional (CFD)</h3>
                    <p>Cada nodo de cÃ³mputo calcula el flujo de fluido en su regiÃ³n. Al final de cada paso de tiempo, todos deben sincronizarse antes de actualizar las condiciones de frontera.</p>
                    <div class="code-block" style="font-size: 14px;">for (int tiempo = 0; tiempo < pasos_simulacion; tiempo++) {
    calcular_flujo_local();
    barrier_wait(&barrera);  // Esperar a todos
    intercambiar_datos_frontera();
    barrier_wait(&barrera);  // Sincronizar antes del siguiente paso
}</div>
                </div>

                <h2>2. Procesamiento de ImÃ¡genes Paralelo</h2>
                <div class="box">
                    <h3>Renderizado 3D y Filtros</h3>
                    <p>Cada hilo procesa una secciÃ³n de la imagen. Antes de aplicar el siguiente filtro, todos deben terminar su secciÃ³n.</p>
                    <div class="code-block" style="font-size: 14px;">void procesar_imagen(int thread_id) {
    aplicar_filtro_blur(mi_seccion);
    barrier_wait(&barrera);  // Todos terminan blur
    
    aplicar_filtro_sharpening(mi_seccion);
    barrier_wait(&barrera);  // Todos terminan sharpening
    
    ajustar_color(mi_seccion);
}</div>
                </div>

                <h2>3. Machine Learning Distribuido</h2>
                <div class="comparison">
                    <div class="comparison-item">
                        <h4>Entrenamiento Paralelo</h4>
                        <p>MÃºltiples workers calculan gradientes en diferentes lotes de datos. Deben sincronizarse para actualizar el modelo global.</p>
                    </div>
                    
                    <div class="comparison-item">
                        <h4>MapReduce</h4>
                        <p>Fase Map: procesar datos en paralelo. Barrera. Fase Reduce: combinar resultados.</p>
                    </div>
                </div>

                <div class="box" style="background: #d1fae5;">
                    <p><strong>ğŸ’¡ PatrÃ³n comÃºn:</strong> Todas estas aplicaciones comparten el patrÃ³n de trabajo paralelo seguido de sincronizaciÃ³n antes de la siguiente fase.</p>
                </div>
            </div>
            <div class="slide-number">15 / 19</div>
        </div>

        <!-- PARTE 2: BARRERAS (DIEGO - 4 SLIDES) -->
        
        <!-- Slide 16 - Diego -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Diego Contreras</div>
            <div class="slide-header">
                <div class="slide-title">ImplementaciÃ³n de Barreras</div>
                <div class="slide-subtitle">Conceptos y LÃ³gica BÃ¡sica</div>
            </div>
            <div class="slide-content">
                <div class="box" style="background: #e0e7ff; border-left-color: #667eea;">
                    <p><strong>ğŸ“Œ Nota importante:</strong> Para implementar barreras se necesitan <span class="highlight">mecanismos de sincronizaciÃ³n bÃ¡sicos</span> como semÃ¡foros o mutex (temas vistos anteriormente en la exposiciÃ³n). AquÃ­ veremos la lÃ³gica conceptual.</p>
                </div>

                <h2>Elementos de una Barrera</h2>
                <div class="comparison">
                    <div class="comparison-item">
                        <h4>ğŸ“Š Variables Necesarias</h4>
                        <ul>
                            <li><strong>Contador:</strong> Procesos que llegaron</li>
                            <li><strong>Total:</strong> Procesos esperados</li>
                            <li><strong>ProtecciÃ³n:</strong> Para el contador</li>
                            <li><strong>Bloqueo:</strong> Para dormir procesos</li>
                        </ul>
                    </div>
                    
                    <div class="comparison-item">
                        <h4>âš™ï¸ Operaciones</h4>
                        <ul>
                            <li><strong>Inicializar:</strong> Configurar total</li>
                            <li><strong>Esperar:</strong> Llegar y sincronizar</li>
                            <li><strong>Liberar:</strong> Despertar a todos</li>
                            <li><strong>Reiniciar:</strong> Para reutilizar</li>
                        </ul>
                    </div>
                </div>

                <h2>LÃ³gica de Funcionamiento</h2>
                <div class="diagram" style="background: #f0fdf4; border-color: #10b981;">
                    <strong>Cuando un proceso llega a la barrera:</strong><br><br>
                    
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>
                    â”‚  1. Incrementar CONTADOR        â”‚<br>
                    â”‚     (de forma protegida)        â”‚<br>
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜<br>
                                  â”‚<br>
                                  â–¼<br>
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>
                    â”‚  2. Â¿Soy el ÃšLTIMO en llegar?   â”‚<br>
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜<br>
                           â”‚                  â”‚<br>
                      NO   â”‚                  â”‚  SÃ<br>
                           â–¼                  â–¼<br>
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”<br>
                    â”‚ ğŸ’¤ DORMIR    â”‚   â”‚ ğŸ”” DESPERTAR â”‚<br>
                    â”‚ (Esperar)    â”‚   â”‚ a TODOS      â”‚<br>
                    â”‚              â”‚   â”‚ + Reiniciar  â”‚<br>
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜<br>
                </div>

                <h2>PseudocÃ³digo Simple</h2>
                <div class="code-block">procedure BARRIER_WAIT(barrera)
    // Paso 1: Registrar mi llegada
    INCREMENTAR barrera.contador
    
    // Paso 2: Decidir quÃ© hacer
    if (barrera.contador == barrera.total) then
        // Soy el Ãºltimo
        DESPERTAR_A_TODOS()
        REINICIAR barrera.contador a 0
    else
        // No soy el Ãºltimo
        DORMIR_HASTA_QUE_TODOS_LLEGUEN()
    end if
end procedure</div>

                <div class="box" style="background: #fef3c7;">
                    <p><strong>ğŸ’¡ Clave:</strong> La barrera es como un portero que cuenta cuÃ¡ntos han llegado. Cuando llega el Ãºltimo, abre la puerta para todos.</p>
                </div>
            </div>
            <div class="slide-number">16 / 19</div>
        </div>

        <!-- Slide 17 - Diego -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Diego Contreras</div>
            <div class="slide-header">
                <div class="slide-title">Ejemplo PrÃ¡ctico y Visual</div>
                <div class="slide-subtitle">Entendiendo las Barreras con un Caso Real</div>
            </div>
            <div class="slide-content">
                <h2>Escenario: 4 Estudiantes Haciendo un Proyecto</h2>
                <p>Cada estudiante tiene tareas que hacer en 3 fases. <strong>NO pueden avanzar a la siguiente fase hasta que TODOS terminen la actual.</strong></p>

                <div class="diagram" style="text-align: left; font-size: 14px;">
                    <strong>FASE 1: InvestigaciÃ³n</strong><br>
                    Derek:  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ âœ“ (termina a los 12 min) â†’ ğŸ’¤ ESPERA<br>
                    Daniel: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ âœ“ (termina a los 7 min) â†’ ğŸ’¤ ESPERA<br>
                    Ergil:  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ âœ“ (termina a los 18 min) â†’ ğŸ’¤ ESPERA<br>
                    Diego:  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ âœ“ (termina a los 20 min) â†’ ğŸš€ ÃšLTIMO<br>
                    <span style="color: #667eea;">[BARRERA] â†’ Cuando Diego termina, TODOS despiertan</span><br>
                    <br>
                    <strong>FASE 2: Escribir cÃ³digo</strong><br>
                    Ahora TODOS comienzan juntos... y repiten el proceso<br>
                </div>

                <h2>CÃ³digo del Ejemplo</h2>
                <div class="code-block">barrier_t barrera;

void estudiante(int id) {
    barrier_init(&barrera, 4);  // 4 estudiantes
    
    // FASE 1: Investigar
    printf("Estudiante %d: Investigando...\n", id);
    investigar();  // Cada uno toma diferente tiempo
    printf("Estudiante %d: TerminÃ© de investigar\n", id);
    
    barrier_wait(&barrera);  // ğŸš§ ESPERAR A TODOS
    
    // FASE 2: Programar (NO llegan aquÃ­ hasta que todos terminen Fase 1)
    printf("Estudiante %d: Programando...\n", id);
    programar();
    printf("Estudiante %d: TerminÃ© de programar\n", id);
    
    barrier_wait(&barrera);  // ğŸš§ ESPERAR A TODOS
    
    // FASE 3: Documentar
    printf("Estudiante %d: Documentando...\n", id);
    documentar();
}</div>

                <div class="box">
                    <h3>Salida del Programa:</h3>
                    <div class="code-block" style="font-size: 14px;">Estudiante 1: Investigando...
Estudiante 2: Investigando...
Estudiante 3: Investigando...
Estudiante 4: Investigando...
Estudiante 2: TerminÃ© de investigar
Estudiante 1: TerminÃ© de investigar
Estudiante 3: TerminÃ© de investigar
Estudiante 4: TerminÃ© de investigar
<span style="color: #10b981;">[Todos esperan en la barrera...]</span>
<span style="color: #10b981;">[Cuando el Ãºltimo llega, todos continÃºan]</span>
Estudiante 1: Programando...
Estudiante 2: Programando...
Estudiante 3: Programando...
Estudiante 4: Programando...</div>
                </div>

                <div class="box" style="background: #fef3c7; margin-top: 20px;">
                    <p><strong>ğŸ’¡ Idea clave:</strong> La barrera asegura que nadie se adelante. Es como un punto de control donde todos deben reunirse antes de continuar.</p>
                </div>
            </div>
            <div class="slide-number">17 / 19</div>
        </div>

        <!-- Slide 18 - Diego -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Diego Contreras</div>
            <div class="slide-header">
                <div class="slide-title">ComparaciÃ³n con Otros Mecanismos</div>
                <div class="slide-subtitle">Â¿CuÃ¡ndo usar Barreras?</div>
            </div>
            <div class="slide-content">
                <h2>Barreras vs Otros Mecanismos de IPC</h2>
                
                <table>
                    <tr>
                        <th>Mecanismo</th>
                        <th>PropÃ³sito</th>
                        <th>Procesos</th>
                        <th>Uso TÃ­pico</th>
                    </tr>
                    <tr>
                        <td><strong>SemÃ¡foros</strong></td>
                        <td>ExclusiÃ³n mutua, sincronizaciÃ³n</td>
                        <td>1 o 2 procesos</td>
                        <td>Proteger recursos compartidos</td>
                    </tr>
                    <tr>
                        <td><strong>Mutexes</strong></td>
                        <td>ExclusiÃ³n mutua</td>
                        <td>1 proceso a la vez</td>
                        <td>Secciones crÃ­ticas</td>
                    </tr>
                    <tr>
                        <td><strong>Pasaje de Mensajes</strong></td>
                        <td>ComunicaciÃ³n</td>
                        <td>2 procesos (tÃ­pico)</td>
                        <td>Transferir datos</td>
                    </tr>
                    <tr>
                        <td><strong>Barreras</strong></td>
                        <td>SincronizaciÃ³n de grupo</td>
                        <td>N procesos</td>
                        <td>Fases paralelas</td>
                    </tr>
                </table>

                <h2>Ventajas de las Barreras</h2>
                <div class="comparison">
                    <div class="comparison-item">
                        <h4>âœ… Ventajas</h4>
                        <ul>
                            <li>Simple de usar y entender</li>
                            <li>Ideal para algoritmos por fases</li>
                            <li>SincronizaciÃ³n clara de mÃºltiples procesos</li>
                            <li>Garantiza consistencia de datos</li>
                        </ul>
                    </div>
                    
                    <div class="comparison-item">
                        <h4>âš ï¸ Limitaciones</h4>
                        <ul>
                            <li>Todos deben llegar (punto de fallo)</li>
                            <li>Puede crear cuellos de botella</li>
                            <li>No apto para comunicaciÃ³n asincrÃ³nica</li>
                            <li>Overhead en sincronizaciÃ³n</li>
                        </ul>
                    </div>
                </div>

                <h2>Casos de Uso Ideales</h2>
                <div class="box">
                    <ul>
                        <li><strong>Simulaciones cientÃ­ficas:</strong> Iteraciones que requieren datos de todos los nodos</li>
                        <li><strong>Procesamiento paralelo:</strong> MapReduce, algoritmos de matriz</li>
                        <li><strong>Renderizado 3D:</strong> Cada frame debe completarse antes del siguiente</li>
                        <li><strong>Machine Learning:</strong> SincronizaciÃ³n de gradientes entre workers</li>
                    </ul>
                </div>
            </div>
            <div class="slide-number">18 / 19</div>
        </div>

        <!-- Slide 19 - Diego NUEVA -->
        <div class="slide">
            <div class="presenter-tag">ğŸ‘¤ Diego Contreras</div>
            <div class="slide-header">
                <div class="slide-title">Optimizaciones y Consideraciones Avanzadas</div>
                <div class="slide-subtitle">Mejorando el Rendimiento de Barreras</div>
            </div>
            <div class="slide-content">
                <h2>Problema: Barreras Centralizadas</h2>
                <div class="box" style="background: #fee;">
                    <p><strong>Cuello de botella:</strong> Todos los procesos compiten por actualizar el mismo contador. En sistemas con muchos procesos, esto causa contenciÃ³n.</p>
                    <div class="diagram" style="background: white;">
                        P1 â†’ â”<br>
                        P2 â†’ â”œâ”€â”€â–º [CONTADOR] â† ContenciÃ³n aquÃ­<br>
                        P3 â†’ â”œâ”€â”€â–º (Todos acceden al mismo recurso)<br>
                        P4 â†’ â”˜<br>
                    </div>
                </div>

                <h2>SoluciÃ³n 1: Barreras JerÃ¡rquicas (Tree Barrier)</h2>
                <div class="box" style="background: #d1fae5;">
                    <p>Organizan los procesos en Ã¡rbol. Cada nivel sincroniza antes de pasar al siguiente.</p>
                    <div class="diagram" style="background: white; font-size: 14px;">
                        Nivel 0:    P1  P2  P3  P4  P5  P6  P7  P8<br>
                                    â””â”¬â”˜ â””â”¬â”˜ â””â”¬â”˜ â””â”¬â”˜<br>
                        Nivel 1:     B1  B2  B3  B4<br>
                                     â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜<br>
                        Nivel 2:        B5      B6<br>
                                        â””â”€â”€â”€â”¬â”€â”€â”€â”˜<br>
                        Root:               BR<br>
                    </div>
                    <p><strong>Ventaja:</strong> Reduce contenciÃ³n de O(N) a O(log N)</p>
                </div>

                <h2>SoluciÃ³n 2: Butterfly Barrier</h2>
                <div class="box">
                    <p>Cada proceso se sincroniza con un subconjunto de procesos en cada fase, creando un patrÃ³n tipo mariposa.</p>
                    <p><strong>Ventaja:</strong> Mejor balance de carga y escalabilidad</p>
                </div>

                <h2>Consideraciones de Rendimiento</h2>
                <table style="font-size: 16px;">
                    <tr>
                        <th>Factor</th>
                        <th>Impacto</th>
                        <th>RecomendaciÃ³n</th>
                    </tr>
                    <tr>
                        <td>NÃºmero de procesos</td>
                        <td>MÃ¡s procesos = mÃ¡s contenciÃ³n</td>
                        <td>Usar barreras jerÃ¡rquicas para N > 64</td>
                    </tr>
                    <tr>
                        <td>Variabilidad de trabajo</td>
                        <td>Desbalance causa esperas largas</td>
                        <td>Balancear carga entre procesos</td>
                    </tr>
                    <tr>
                        <td>Frecuencia de barreras</td>
                        <td>Barreras frecuentes = overhead</td>
                        <td>Agrupar trabajo entre barreras</td>
                    </tr>
                </table>

                <div class="box" style="background: #fef3c7; margin-top: 15px;">
                    <p><strong>ğŸ’¡ Regla de oro:</strong> Las barreras son herramientas poderosas pero costosas. Ãšsalas solo cuando realmente necesites sincronizaciÃ³n global de todos los procesos.</p>
                </div>
            </div>
            <div class="slide-number">19 / 19</div>
        </div>

        <!-- Slide 20: ConclusiÃ³n -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-title">Conclusiones</div>
                <div class="slide-subtitle">Resumen de Conceptos Clave</div>
            </div>
            <div class="slide-content">
                <h2>Pasaje de Mensajes</h2>
                <div class="box">
                    <ul>
                        <li>âœ“ Mecanismo sin memoria compartida</li>
                        <li>âœ“ ComunicaciÃ³n directa e indirecta</li>
                        <li>âœ“ SincronizaciÃ³n bloqueante/no bloqueante</li>
                        <li>âœ“ Ideal para sistemas distribuidos</li>
                        <li>âœ“ Requiere manejo cuidadoso de deadlocks</li>
                    </ul>
                </div>

                <h2>Barreras</h2>
                <div class="box">
                    <ul>
                        <li>âœ“ SincronizaciÃ³n de grupos de procesos</li>
                        <li>âœ“ Todos esperan hasta que todos lleguen</li>
                        <li>âœ“ Perfectas para algoritmos por fases</li>
                        <li>âœ“ Usadas en computaciÃ³n paralela</li>
                        <li>âœ“ Optimizaciones para sistemas grandes</li>
                    </ul>
                </div>

                <h2>RelaciÃ³n entre Ambos</h2>
                <p style="font-size: 22px; margin-top: 20px;">Tanto el <span class="highlight">pasaje de mensajes</span> como las <span class="highlight">barreras</span> son herramientas complementarias en IPC:</p>
                <div class="diagram">
                    <strong>Pasaje de Mensajes</strong> â†’ ComunicaciÃ³n y transferencia de datos
                    <br>
                    <strong>Barreras</strong> â†’ SincronizaciÃ³n y coordinaciÃ³n de fases
                    <br><br>
                    Juntos permiten construir sistemas paralelos robustos y eficientes
                </div>

                <div class="box" style="background: #d1fae5; border-left-color: #10b981; margin-top: 30px;">
                    <h3 style="color: #10b981;">ğŸ’¡ Mensaje Final</h3>
                    <p>La elecciÃ³n del mecanismo depende del problema: usa pasaje de mensajes para comunicaciÃ³n y barreras para sincronizaciÃ³n de grupo. Conocer las fortalezas y limitaciones de cada uno te permite diseÃ±ar sistemas concurrentes eficientes y confiables.</p>
                </div>
            </div>
            <div class="slide-number">20 / 19</div>
        </div>

        <!-- Slide 21: Referencias -->
        <div class="slide">
            <div class="slide-header">
                <div class="slide-title">Referencias y Recursos</div>
            </div>
            <div class="slide-content">
                <h2>BibliografÃ­a Recomendada</h2>
                <div class="box">
                    <ul>
                        <li><strong>Tanenbaum, A. S.</strong> - "Modern Operating Systems" (CapÃ­tulo 2: Procesos e Hilos)</li>
                        <li><strong>Silberschatz, Galvin, Gagne</strong> - "Operating System Concepts" (CapÃ­tulo 3: Procesos)</li>
                        <li><strong>Stevens, W. R.</strong> - "UNIX Network Programming" (IPC)</li>
                        <li><strong>Andrews, G. R.</strong> - "Foundations of Multithreaded, Parallel, and Distributed Programming"</li>
                    </ul>
                </div>

                <h2>APIs y LibrerÃ­as</h2>
                <div class="box">
                    <ul>
                        <li><strong>POSIX Threads (pthreads):</strong> pthread_barrier_wait(), pthread_barrier_init()</li>
                        <li><strong>MPI (Message Passing Interface):</strong> MPI_Send(), MPI_Recv(), MPI_Barrier()</li>
                        <li><strong>OpenMP:</strong> #pragma omp barrier</li>
                        <li><strong>Java:</strong> CyclicBarrier, Phaser</li>
                    </ul>
                </div>

                <h2>Recursos Online</h2>
                <div class="box">
                    <ul>
                        <li>Linux Man Pages: man 3 pthread_barrier</li>
                        <li>MPI Tutorial: https://mpitutorial.com</li>
                        <li>Operating Systems: Three Easy Pieces (libro gratuito)</li>
                        <li>Parallel Programming Patterns: patterns.eecs.berkeley.edu</li>
                    </ul>
                </div>

                <div style="text-align: center; margin-top: 50px; font-size: 36px; color: #667eea;">
                    <strong>Â¡Gracias por su atenciÃ³n!</strong>
                    <br>
                    <span style="font-size: 24px; color: #4a5568;">Â¿Preguntas?</span>
                </div>
            </div>
            <div class="slide-number">21 / 19</div>
        </div>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;

        function showSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + totalSlides) % totalSlides;
            slides[currentSlide].classList.add('active');
        }

        function nextSlide() {
            if (currentSlide < totalSlides - 1) {
                showSlide(currentSlide + 1);
            }
        }

        function prevSlide() {
            if (currentSlide > 0) {
                showSlide(currentSlide - 1);
            }
        }

        // Agregar botones de navegaciÃ³n a cada slide
        slides.forEach((slide, index) => {
            const nav = document.createElement('div');
            nav.className = 'navigation';
            
            const prevBtn = document.createElement('button');
            prevBtn.className = 'nav-btn';
            prevBtn.textContent = 'â† Anterior';
            prevBtn.onclick = prevSlide;
            prevBtn.disabled = index === 0;
            
            const nextBtn = document.createElement('button');
            nextBtn.className = 'nav-btn';
            nextBtn.textContent = index === totalSlides - 1 ? 'Fin' : 'Siguiente â†’';
            nextBtn.onclick = nextSlide;
            nextBtn.disabled = index === totalSlides - 1;
            
            if (index > 0) nav.appendChild(prevBtn);
            if (index < totalSlides - 1) nav.appendChild(nextBtn);
            
            slide.appendChild(nav);
        });

        // NavegaciÃ³n con teclado
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                prevSlide();
            }
        });

        // Actualizar nÃºmeros de slide
        function updateSlideNumbers() {
            slides.forEach((slide, index) => {
                const slideNumber = slide.querySelector('.slide-number');
                if (slideNumber) {
                    slideNumber.textContent = `${index + 1} / ${totalSlides}`;
                }
            });
        }

        updateSlideNumbers();
    </script>
</body>